import * as fs from 'fs';
import * as path from 'path';
import type { PredictionIntervals, ReliabilityAnalysis } from './guards.confidence';
import type { BenchmarkStats } from './guards.benchmark';

/**
 * Performance data export utilities
 */
class PerformanceExporter {
    private outputDir: string;

    constructor(outputDir: string = 'export-results') {
        this.outputDir = outputDir;
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
    }

    /**
     * Export performance data in multiple formats
     */
    async exportData(
        name: string,
        historical: BenchmarkStats[],
        predictions: BenchmarkStats[],
        intervals: PredictionIntervals[],
        reliability: ReliabilityAnalysis
    ): Promise<void> {
        await Promise.all([
            this.exportCSV(name, historical, predictions, intervals),
            this.exportJSON(name, historical, predictions, intervals, reliability),
            this.exportMarkdown(name, historical, predictions, intervals, reliability),
            this.exportHTML(name, historical, predictions, intervals, reliability)
        ]);
    }

    /**
     * Export data as CSV
     */
    private async exportCSV(
        name: string,
        historical: BenchmarkStats[],
        predictions: BenchmarkStats[],
        intervals: PredictionIntervals[]
    ): Promise<void> {
        const metrics = ['executionTime', 'memory', 'gc'];

        metrics.forEach(metric => {
            const headers = ['Timestamp', 'Type', 'Value', 'Lower Bound', 'Upper Bound'];
            const rows = [
                // Historical data
                ...historical.map(h => [
                    new Date().toISOString(),
                    'Historical',
                    h[metric].mean,
                    '',
                    ''
                ]),
                // Predictions with intervals
                ...predictions.map((p, i) => [
                    new Date().toISOString(),
                    'Predicted',
                    p[metric].mean,
                    intervals[i][metric].lower,
                    intervals[i][metric].upper
                ])
            ];

            const csv = [
                headers.join(','),
                ...rows.map(row => row.join(','))
            ].join('\n');

            fs.writeFileSync(
                path.join(this.outputDir, `${name}_${metric}.csv`),
                csv
            );
        });
    }

    /**
     * Export data as JSON
     */
    private async exportJSON(
        name: string,
        historical: BenchmarkStats[],
        predictions: BenchmarkStats[],
        intervals: PredictionIntervals[],
        reliability: ReliabilityAnalysis
    ): Promise<void> {
        const data = {
            name,
            timestamp: new Date().toISOString(),
            metrics: {
                executionTime: this.formatMetricData('executionTime', historical, predictions, intervals),
                memory: this.formatMetricData('memory', historical, predictions, intervals),
                gc: this.formatMetricData('gc', historical, predictions, intervals)
            },
            reliability,
            metadata: {
                historicalCount: historical.length,
                predictionCount: predictions.length,
                exportVersion: '1.0.0'
            }
        };

        fs.writeFileSync(
            path.join(this.outputDir, `${name}.json`),
            JSON.stringify(data, null, 2)
        );
    }

    /**
     * Export data as Markdown
     */
    private async exportMarkdown(
        name: string,
        historical: BenchmarkStats[],
        predictions: BenchmarkStats[],
        intervals: PredictionIntervals[],
        reliability: ReliabilityAnalysis
    ): Promise<void> {
        const markdown = `
# ${name} - Performance Analysis Report

Generated: ${new Date().toLocaleString()}

## Overview

- Historical Data Points: ${historical.length}
- Predictions: ${predictions.length}
- Confidence Level: 95%

## Metrics

### Execution Time

${this.formatMetricMarkdown('executionTime', historical, predictions, intervals)}

### Memory Usage

${this.formatMetricMarkdown('memory', historical, predictions, intervals)}

### Garbage Collection

${this.formatMetricMarkdown('gc', historical, predictions, intervals)}

## Reliability Analysis

${this.formatReliabilityMarkdown(reliability)}

## Recommendations

${reliability.recommendations.map(rec => `- ${rec}`).join('\n')}

## Export Information

- Version: 1.0.0
- Format: Markdown
- Generated by: Performance Analysis Tool
`;

        fs.writeFileSync(
            path.join(this.outputDir, `${name}.md`),
            markdown
        );
    }

    /**
     * Export data as HTML
     */
    private async exportHTML(
        name: string,
        historical: BenchmarkStats[],
        predictions: BenchmarkStats[],
        intervals: PredictionIntervals[],
        reliability: ReliabilityAnalysis
    ): Promise<void> {
        const html = `
<!DOCTYPE html>
<html>
    <head>
        <title>${name} - Performance Analysis Report</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                line-height: 1.6;
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
            }
            table {
                width: 100%;
                border-collapse: collapse;
                margin: 20px 0;
            }
            th, td {
                padding: 8px;
                border: 1px solid #ddd;
                text-align: left;
            }
            th {
                background-color: #f5f5f5;
            }
            .metric {
                margin: 20px 0;
                padding: 20px;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            .reliability {
                margin: 20px 0;
                padding: 20px;
                background-color: #f8f9fa;
                border-radius: 4px;
            }
            .recommendations {
                margin: 20px 0;
                padding: 20px;
                background-color: #e9ecef;
                border-radius: 4px;
            }
            .trend-positive { color: #28a745; }
            .trend-negative { color: #dc3545; }
            .trend-neutral { color: #ffc107; }
        </style>
    </head>
    <body>
        <h1>${name} - Performance Analysis Report</h1>
        <p>Generated: ${new Date().toLocaleString()}</p>

        <h2>Overview</h2>
        <ul>
            <li>Historical Data Points: ${historical.length}</li>
            <li>Predictions: ${predictions.length}</li>
            <li>Confidence Level: 95%</li>
        </ul>

        <h2>Metrics</h2>

        <div class="metric">
            <h3>Execution Time</h3>
            ${this.formatMetricHTML('executionTime', historical, predictions, intervals)}
        </div>

        <div class="metric">
            <h3>Memory Usage</h3>
            ${this.formatMetricHTML('memory', historical, predictions, intervals)}
        </div>

        <div class="metric">
            <h3>Garbage Collection</h3>
            ${this.formatMetricHTML('gc', historical, predictions, intervals)}
        </div>

        <div class="reliability">
            <h2>Reliability Analysis</h2>
            ${this.formatReliabilityHTML(reliability)}
        </div>

        <div class="recommendations">
            <h2>Recommendations</h2>
            <ul>
                ${reliability.recommendations.map(rec => `<li>${rec}</li>`).join('\n')}
            </ul>
        </div>

        <footer>
            <p>Export Version: 1.0.0</p>
            <p>Generated by: Performance Analysis Tool</p>
        </footer>
    </body>
</html>`;

        fs.writeFileSync(
            path.join(this.outputDir, `${name}.html`),
            html
        );
    }

    /**
     * Format metric data for JSON export
     */
    private formatMetricData(
        metric: string,
        historical: BenchmarkStats[],
        predictions: BenchmarkStats[],
        intervals: PredictionIntervals[]
    ): any {
        return {
            historical: historical.map(h => ({
                timestamp: new Date().toISOString(),
                value: h[metric].mean
            })),
            predictions: predictions.map((p, i) => ({
                timestamp: new Date().toISOString(),
                value: p[metric].mean,
                confidence: {
                    lower: intervals[i][metric].lower,
                    upper: intervals[i][metric].upper
                }
            }))
        };
    }

    /**
     * Format metric data for Markdown
     */
    private formatMetricMarkdown(
        metric: string,
        historical: BenchmarkStats[],
        predictions: BenchmarkStats[],
        intervals: PredictionIntervals[]
    ): string {
        const stats = this.calculateStats(metric, historical, predictions);
        return `
#### Statistics
- Mean: ${stats.mean.toFixed(2)}
- Trend: ${stats.trend > 0 ? '+' : ''}${(stats.trend * 100).toFixed(1)}%
- Prediction Accuracy: ${stats.accuracy.toFixed(1)}%

#### Latest Values
- Current: ${historical[historical.length - 1][metric].mean.toFixed(2)}
- Predicted: ${predictions[0][metric].mean.toFixed(2)}
- Confidence Interval: [${intervals[0][metric].lower.toFixed(2)}, ${intervals[0][metric].upper.toFixed(2)}]
`;
    }

    /**
     * Format metric data for HTML
     */
    private formatMetricHTML(
        metric: string,
        historical: BenchmarkStats[],
        predictions: BenchmarkStats[],
        intervals: PredictionIntervals[]
    ): string {
        const stats = this.calculateStats(metric, historical, predictions);
        return `
            <table>
                <tr>
                    <th>Statistic</th>
                    <th>Value</th>
                </tr>
                <tr>
                    <td>Mean</td>
                    <td>${stats.mean.toFixed(2)}</td>
                </tr>
                <tr>
                    <td>Trend</td>
                    <td class="${this.getTrendClass(stats.trend)}">
                        ${stats.trend > 0 ? '+' : ''}${(stats.trend * 100).toFixed(1)}%
                    </td>
                </tr>
                <tr>
                    <td>Prediction Accuracy</td>
                    <td>${stats.accuracy.toFixed(1)}%</td>
                </tr>
            </table>

            <h4>Latest Values</h4>
            <table>
                <tr>
                    <td>Current</td>
                    <td>${historical[historical.length - 1][metric].mean.toFixed(2)}</td>
                </tr>
                <tr>
                    <td>Predicted</td>
                    <td>${predictions[0][metric].mean.toFixed(2)}</td>
                </tr>
                <tr>
                    <td>Confidence Interval</td>
                    <td>[${intervals[0][metric].lower.toFixed(2)}, ${intervals[0][metric].upper.toFixed(2)}]</td>
                </tr>
            </table>
        `;
    }

    /**
     * Format reliability analysis for Markdown
     */
    private formatReliabilityMarkdown(reliability: ReliabilityAnalysis): string {
        return `
### Trend Analysis

- Execution Time: ${this.formatReliabilityTrend(reliability.trends.executionTime)}
- Memory Usage: ${this.formatReliabilityTrend(reliability.trends.memory)}
- GC Activity: ${this.formatReliabilityTrend(reliability.trends.gc)}
`;
    }

    /**
     * Format reliability analysis for HTML
     */
    private formatReliabilityHTML(reliability: ReliabilityAnalysis): string {
        return `
            <table>
                <tr>
                    <th>Metric</th>
                    <th>Reliability</th>
                </tr>
                <tr>
                    <td>Execution Time</td>
                    <td class="${this.getReliabilityClass(reliability.trends.executionTime)}">
                        ${this.formatReliabilityTrend(reliability.trends.executionTime)}
                    </td>
                </tr>
                <tr>
                    <td>Memory Usage</td>
                    <td class="${this.getReliabilityClass(reliability.trends.memory)}">
                        ${this.formatReliabilityTrend(reliability.trends.memory)}
                    </td>
                </tr>
                <tr>
                    <td>GC Activity</td>
                    <td class="${this.getReliabilityClass(reliability.trends.gc)}">
                        ${this.formatReliabilityTrend(reliability.trends.gc)}
                    </td>
                </tr>
            </table>
        `;
    }

    /**
     * Calculate statistics for a metric
     */
    private calculateStats(
        metric: string,
        historical: BenchmarkStats[],
        predictions: BenchmarkStats[]
    ): { mean: number; trend: number; accuracy: number } {
        const values = historical.map(h => h[metric].mean);
        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        const trend = (values[values.length - 1] - values[0]) / values[0];

        // Calculate prediction accuracy using last few historical values
        const testSize = Math.min(3, historical.length - 1);
        const actualValues = historical.slice(-testSize).map(h => h[metric].mean);
        const predictedValues = predictions.slice(0, testSize).map(p => p[metric].mean);
        const errors = actualValues.map((actual, i) =>
            Math.abs((predictedValues[i] - actual) / actual)
        );
        const accuracy = (1 - errors.reduce((a, b) => a + b, 0) / errors.length) * 100;

        return { mean, trend, accuracy };
    }

    /**
     * Format reliability trend
     */
    private formatReliabilityTrend(trend: number): string {
        if (trend <= 0.1) return 'High Reliability';
        if (trend <= 0.2) return 'Moderate Reliability';
        return 'Low Reliability';
    }

    /**
     * Get trend CSS class
     */
    private getTrendClass(trend: number): string {
        if (Math.abs(trend) < 0.05) return 'trend-neutral';
        return trend < 0 ? 'trend-positive' : 'trend-negative';
    }

    /**
     * Get reliability CSS class
     */
    private getReliabilityClass(trend: number): string {
        if (trend <= 0.1) return 'trend-positive';
        if (trend <= 0.2) return 'trend-neutral';
        return 'trend-negative';
    }
}

export { PerformanceExporter };
